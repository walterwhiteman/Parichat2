// src/hooks/useFirebase.ts
import { useState, useEffect, useCallback } from 'react';
import {
  collection,
  doc,
  addDoc,
  setDoc,
  getDoc,
  query,
  orderBy,
  onSnapshot,
  serverTimestamp,
  updateDoc
} from 'firebase/firestore';
import { ref as storageRef, uploadBytes, getDownloadURL } from 'firebase/storage';
import { db, storage } from '../config/firebase'; // Ensure 'db' (Firestore) is imported
import { User, Message, Room } from '../types'; // Assuming your types are compatible

export const useFirebase = (roomId: string, userId: string, username: string) => {
  const [room, setRoom] = useState<Room | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [users, setUsers] = useState<User[]>([]);

  // Firestore References
  const roomDocRef = doc(db, 'rooms', roomId);
  const usersCollectionRef = collection(db, 'rooms', roomId, 'users');
  const userDocRef = doc(db, 'rooms', roomId, 'users', userId);
  const messagesCollectionRef = collection(db, 'rooms', roomId, 'messages');

  // --- Send Message (Firestore) ---
  const sendMessage = useCallback(async (content: string, type: 'text' | 'image' | 'file' = 'text', fileUrl?: string, fileName?: string) => {
    if (!roomId || !userId || (!content.trim() && !fileUrl)) {
      console.warn("Attempted to send empty message or missing room/user ID.");
      return;
    }

    try {
      const newMessage: Partial<Message> = { // Use Partial as ID is generated by Firestore
        senderId: userId,
        senderName: username,
        content: content, // Content for text messages, or empty for file
        timestamp: serverTimestamp(), // Firestore's server timestamp
        type: type
      };

      if (fileUrl) {
        newMessage.fileUrl = fileUrl;
      }
      if (fileName) {
        newMessage.fileName = fileName;
      }

      await addDoc(messagesCollectionRef, newMessage);
      console.log('Message sent to Firestore:', newMessage);
    } catch (error) {
      console.error('Error sending message to Firestore:', error);
    }
  }, [roomId, userId, username]);

  // --- Upload File (Storage) ---
  const uploadFile = useCallback(async (file: File): Promise<string> => {
    try {
      const fileReference = storageRef(storage, `files/${roomId}/${Date.now()}_${file.name}`);
      const snapshot = await uploadBytes(fileReference, file);
      const url = await getDownloadURL(snapshot.ref);
      console.log('File uploaded to Storage:', url);
      return url;
    } catch (error) {
      console.error('Error uploading file to Storage:', error);
      throw error; // Re-throw to be caught by handleFileUpload in ChatRoom
    }
  }, [roomId]);

  // --- Set Typing Status (Firestore) ---
  const setTypingStatus = useCallback(async (typing: boolean) => {
    if (!roomId || !userId) return;
    try {
      await updateDoc(userDocRef, { isTyping: typing });
    } catch (error) {
      console.error('Error setting typing status:', error);
    }
  }, [roomId, userId]);

  // --- Add Reaction (Firestore) ---
  const addReaction = useCallback(async (messageId: string, emoji: string) => {
    if (!roomId || !userId) return;
    try {
      const reactionDocRef = doc(db, 'rooms', roomId, 'messages', messageId);
      await updateDoc(reactionDocRef, {
        [`reactions.${userId}`]: emoji
      });
      console.log(`Reaction ${emoji} added by ${userId} to message ${messageId}`);
    } catch (error) {
      console.error('Error adding reaction:', error);
    }
  }, [roomId, userId]);


  // --- Effect Hook for Real-time Data (Firestore) ---
  useEffect(() => {
    if (!roomId || !userId) return;

    // --- User Presence Setup (async function) ---
    const setupUserPresence = async () => {
      try {
        const roomSnapshot = await getDoc(roomDocRef);
        const roomData = roomSnapshot.data() as Room;

        // Note: For 'users' subcollection, getting roomData.users directly might not be ideal.
        // You're listening to usersCollectionRef below for real-time updates.
        // This 'room full' logic would be better managed via a Cloud Function on user joins/leaves
        // or by directly querying the usersCollectionRef here.
        // For now, we'll proceed assuming the user can join.

        await setDoc(userDocRef, {
          id: userId,
          username: username,
          isOnline: true,
          lastSeen: serverTimestamp(),
          isTyping: false
        }, { merge: true }); // Use merge: true to update existing fields without overwriting the whole document

      } catch (error) {
        console.error('Error during user presence setup:', error);
      }
    };

    // --- Cleanup function for user presence (run when component unmounts) ---
    const cleanupUserPresence = () => {
      // Mark user as offline when component unmounts or hook dependencies change
      updateDoc(userDocRef, {
        isOnline: false,
        lastSeen: serverTimestamp(),
        isTyping: false
      }).catch(error => console.error("Error setting user offline on unmount:", error));
    };

    // Call the setup function when effect runs
    setupUserPresence();

    // --- Real-time Listeners for Users and Messages ---
    const usersQuery = query(usersCollectionRef, orderBy('lastSeen', 'desc'));
    const unsubscribeUsers = onSnapshot(usersQuery, (snapshot) => {
      const fetchedUsers: User[] = [];
      snapshot.forEach(doc => {
        fetchedUsers.push(doc.data() as User);
      });
      setUsers(fetchedUsers);
      console.log('Users updated:', fetchedUsers);
    }, (error) => {
      console.error('Error fetching users:', error);
    });

    const messagesQuery = query(messagesCollectionRef, orderBy('timestamp', 'asc'));
    const unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
      const fetchedMessages: Message[] = [];
      snapshot.forEach(doc => {
        fetchedMessages.push({ id: doc.id, ...doc.data() } as Message);
      });
      setMessages(fetchedMessages);
      console.log('Messages updated:', fetchedMessages);
    }, (error) => {
      console.error('Error fetching messages:', error);
    });

    // --- Overall Cleanup for useEffect ---
    return () => {
      cleanupUserPresence(); // Mark user offline
      unsubscribeUsers();
      unsubscribeMessages();
      console.log('Firebase listeners cleaned up.');
    };

  }, [roomId, userId, username]); // Dependencies for useEffect

  // Return the necessary states and functions
  return {
    room,
    messages,
    users,
    sendMessage,
    uploadFile,
    setTypingStatus,
    addReaction
  };
};
