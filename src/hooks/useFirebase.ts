// src/hooks/useFirebase.ts
import { useState, useEffect, useCallback } from 'react';
import {
  collection,
  doc,
  addDoc,
  setDoc,
  getDoc,
  query,
  orderBy,
  limit,
  onSnapshot,
  serverTimestamp,
  where,
  updateDoc
} from 'firebase/firestore';
import { ref as storageRef, uploadBytes, getDownloadURL } from 'firebase/storage';
import { db, storage } from '../config/firebase'; // Ensure 'db' (Firestore) is imported
import { User, Message, Room } from '../types'; // Assuming your types are compatible

export const useFirebase = (roomId: string, userId: string, username: string) => {
  const [room, setRoom] = useState<Room | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [users, setUsers] = useState<User[]>([]);

  // Firestore References
  const roomDocRef = doc(db, 'rooms', roomId);
  const usersCollectionRef = collection(db, 'rooms', roomId, 'users');
  const userDocRef = doc(db, 'rooms', roomId, 'users', userId);
  const messagesCollectionRef = collection(db, 'rooms', roomId, 'messages');

  // --- Send Message (Firestore) ---
  const sendMessage = useCallback(async (content: string, type: 'text' | 'image' | 'file' = 'text', fileUrl?: string, fileName?: string) => {
    if (!roomId || !userId || (!content.trim() && !fileUrl)) {
      console.warn("Attempted to send empty message or missing room/user ID.");
      return;
    }

    try {
      const newMessage: Partial<Message> = { // Use Partial as ID is generated by Firestore
        senderId: userId,
        senderName: username,
        content: content, // Content for text messages, or empty for file
        timestamp: serverTimestamp(), // Firestore's server timestamp
        type: type
      };

      if (fileUrl) {
        newMessage.fileUrl = fileUrl;
      }
      if (fileName) {
        newMessage.fileName = fileName;
      }

      await addDoc(messagesCollectionRef, newMessage);
      console.log('Message sent to Firestore:', newMessage);
    } catch (error) {
      console.error('Error sending message to Firestore:', error);
    }
  }, [roomId, userId, username]); // Dependencies for useCallback

  // --- Upload File (Storage) ---
  const uploadFile = useCallback(async (file: File): Promise<string> => {
    try {
      const fileReference = storageRef(storage, `files/${roomId}/${Date.now()}_${file.name}`);
      const snapshot = await uploadBytes(fileReference, file);
      const url = await getDownloadURL(snapshot.ref);
      console.log('File uploaded to Storage:', url);
      return url;
    } catch (error) {
      console.error('Error uploading file to Storage:', error);
      throw error; // Re-throw to be caught by handleFileUpload in ChatRoom
    }
  }, [roomId]);

  // --- Set Typing Status (Firestore) ---
  const setTypingStatus = useCallback(async (typing: boolean) => {
    if (!roomId || !userId) return;
    try {
      await updateDoc(userDocRef, { isTyping: typing });
    } catch (error) {
      console.error('Error setting typing status:', error);
    }
  }, [roomId, userId]);

  // --- Add Reaction (Firestore) ---
  const addReaction = useCallback(async (messageId: string, emoji: string) => {
    if (!roomId || !userId) return;
    try {
      // Use arrayUnion/arrayRemove if you want multiple users to react to the same message with distinct emojis
      // For simplicity, this overwrites if the same user reacts again
      const reactionDocRef = doc(db, 'rooms', roomId, 'messages', messageId);
      await updateDoc(reactionDocRef, {
        [`reactions.${userId}`]: emoji // Adds/updates a field like 'reactions.user123': '👍'
      });
      console.log(`Reaction ${emoji} added by ${userId} to message ${messageId}`);
    } catch (error) {
      console.error('Error adding reaction:', error);
    }
  }, [roomId, userId]);


  // --- Effect Hook for Real-time Data (Firestore) ---
  useEffect(() => {
    if (!roomId || !userId) return;

    // --- User Presence & Room Full Logic ---
    const setupUserPresence = async () => {
      try {
        const roomSnapshot = await getDoc(roomDocRef);
        const roomData = roomSnapshot.data() as Room;

        if (roomData && roomData.users) {
          const existingUsers = Object.values(roomData.users) as User[];
          const onlineUsers = existingUsers.filter(user => user.isOnline);
          const existingUser = existingUsers.find(user => user.username === username);

          // If room is full (2 users) and this user is not one of them, don't allow entry
          // This logic is more complex with Firestore as you need to manage user documents
          // For simplicity, we'll allow joining, but you might want to implement a more robust
          // solution, e.g., a "join" cloud function that checks user count.
          // For now, let's proceed and mark user online.
          if (onlineUsers.length >= 2 && !existingUser) {
             console.warn('Room is full. Consider implementing stricter join logic.');
             // alert('Room is full. Only 2 users are allowed.'); // This might be disruptive
             // return; // If you want to prevent entry
          }
        }

        // Set user as online and add/update their info in the subcollection
        await setDoc(userDocRef, {
          id: userId,
          username: username,
          isOnline: true,
          lastSeen: serverTimestamp(),
          isTyping: false
        }, { merge: true }); // Use merge: true to update existing fields without overwriting the whole document

        // Cleanup function for when component unmounts or dependencies change
        return () => {
          // Mark user as offline when component unmounts or hook dependencies change
          updateDoc(userDocRef, {
            isOnline: false,
            lastSeen: serverTimestamp(),
            isTyping: false
          }).catch(error => console.error("Error setting user offline on unmount:", error));
        };

      } catch (error) {
        console.error('Error during user presence setup:', error);
      }
    };

    const userPresenceCleanup = setupUserPresence(); // Call the async function

    // --- Real-time Listeners for Users and Messages ---
    const usersQuery = query(usersCollectionRef, orderBy('lastSeen', 'desc')); // Order users for display
    const unsubscribeUsers = onSnapshot(usersQuery, (snapshot) => {
      const fetchedUsers: User[] = [];
      snapshot.forEach(doc => {
        fetchedUsers.push(doc.data() as User);
      });
      setUsers(fetchedUsers);
      console.log('Users updated:', fetchedUsers);
    }, (error) => {
      console.error('Error fetching users:', error);
    });

    const messagesQuery = query(messagesCollectionRef, orderBy('timestamp', 'asc')); // Order messages by time
    const unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
      const fetchedMessages: Message[] = [];
      snapshot.forEach(doc => {
        fetchedMessages.push({ id: doc.id, ...doc.data() } as Message); // Add doc.id
      });
      setMessages(fetchedMessages);
      console.log('Messages updated:', fetchedMessages);
    }, (error) => {
      console.error('Error fetching messages:', error);
    });


    // --- Cleanup Listeners ---
    return () => {
      if (typeof userPresenceCleanup === 'function') { // Check if cleanup function was returned
        userPresenceCleanup();
      }
      unsubscribeUsers();
      unsubscribeMessages();
      console.log('Firebase listeners cleaned up.');
    };

  }, [roomId, userId, username]); // Dependencies for useEffect

  // Return the necessary states and functions
  return {
    room, // Room data itself is not directly listened to in this setup but can be added
    messages,
    users,
    sendMessage,
    uploadFile,
    setTypingStatus,
    addReaction
  };
};
